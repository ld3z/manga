---
interface Props {
  currentSlugs?: string[];
}

const { currentSlugs = [] } = Astro.props;

import { availableLanguages, languageMap } from '../lib/api';

const languages = [
  { value: 'en', label: 'English' },
  { value: 'ja', label: 'Japanese' },
  { value: 'ko', label: 'Korean' },
  { value: 'zh', label: 'Chinese' },
  { value: 'fr', label: 'French' },
  { value: 'es', label: 'Spanish' },
  { value: 'it', label: 'Italian' },
  { value: 'de', label: 'German' },
  { value: 'tr', label: 'Turkish' },
  { value: 'pl', label: 'Polish' },
];
---

<div class="space-y-6">
  <div class="flex flex-col gap-4">
    <div class="flex gap-2">
      <div class="flex-1">
        <input
          type="text"
          id="search-input"
          placeholder="Search for comics..."
          class="w-full px-4 py-2 bg-primary rounded-lg border border-hover/30 focus:outline-none focus:border-accent/50 transition-colors"
        />
      </div>
      <select
        id="lang-select"
        class="px-4 py-2 bg-primary rounded-lg border border-hover/30 focus:outline-none focus:border-accent/50 transition-colors"
      >
        {languages.map(lang => (
          <option value={lang.value}>{lang.label}</option>
        ))}
      </select>
    </div>

    <div id="search-results" class="hidden space-y-2">
      <!-- Search results will be populated here -->
    </div>
  </div>

  <div id="slug-list" class="space-y-2">
    {currentSlugs.map(slug => (
      <div class="flex items-center justify-between p-3 bg-primary rounded-lg border border-hover/30" data-slug={slug}>
        <span class="text-primary">{slug}</span>
        <button 
          class="text-red-500 hover:text-red-600 transition-colors"
          data-remove={slug}
        >
          <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
    ))}
  </div>

  <div class="flex justify-center">
    <a
      id="generate-rss"
      href="/rss/custom/"
      class="inline-flex items-center gap-2 px-6 py-3 bg-[rgb(var(--accent-bg))] text-[rgb(var(--accent-text))] rounded-lg hover:bg-[rgb(var(--accent-light))] transition-colors"
      onclick="return !!this.href.includes(',')"
    >
      <svg
        class="w-5 h-5"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M4 11a9 9 0 0 1 9 9"></path>
        <path d="M4 4a16 16 0 0 1 16 16"></path>
        <circle cx="5" cy="19" r="1"></circle>
      </svg>
      Generate RSS Feed
    </a>
  </div>
</div>

<script>
  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const searchResults = document.getElementById('search-results');
  const slugList = document.getElementById('slug-list');
  const generateRSSLink = document.getElementById('generate-rss');
  const langSelect = document.getElementById('lang-select') as HTMLSelectElement;

  // Load saved slugs from localStorage
  let slugs = new Set(JSON.parse(localStorage.getItem('comic-slugs') || '[]'));
  
  function updateSlugs() {
    localStorage.setItem('comic-slugs', JSON.stringify([...slugs]));
    updateRSSLink();
    renderSlugs();
  }

  function renderSlugs() {
    if (!slugList) return;
    
    slugList.innerHTML = '';
    [...slugs].forEach(slug => {
      const div = document.createElement('div');
      div.className = 'flex items-center justify-between p-3 bg-primary rounded-lg border border-hover/30';
      
      const text = document.createElement('span');
      text.textContent = slug;
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'text-red-500 hover:text-red-600 transition-colors';
      removeBtn.innerHTML = `
        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      `;
      removeBtn.onclick = () => {
        slugs.delete(slug);
        updateSlugs();
      };
      
      div.appendChild(text);
      div.appendChild(removeBtn);
      slugList.appendChild(div);
    });
  }

  let searchTimeout: NodeJS.Timeout;
  searchInput?.addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(async () => {
      const query = searchInput.value.trim();
      if (query.length < 2) {
        searchResults!.classList.add('hidden');
        return;
      }

      try {
        searchResults!.innerHTML = `
          <div class="p-3 bg-primary rounded-lg border border-hover/30">
            Searching...
          </div>
        `;
        searchResults!.classList.remove('hidden');

        const response = await fetch('/api/search', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ query })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || !Array.isArray(data) || data.length === 0) {
          searchResults!.innerHTML = `
            <div class="p-3 bg-primary rounded-lg border border-hover/30">
              No comics found
            </div>
          `;
          return;
        }
        
        searchResults!.innerHTML = '';
        
        data.forEach((comic: any) => {
          const div = document.createElement('div');
          div.className = 'flex items-center gap-3 p-3 bg-primary rounded-lg border border-hover/30 cursor-pointer hover:border-accent/50 transition-colors';
          div.onclick = () => {
            slugs.add(comic.slug);
            updateSlugs();
            searchInput.value = '';
            searchResults!.classList.add('hidden');
          };
          
          if (comic.md_covers && comic.md_covers[0]) {
            const img = document.createElement('img');
            img.src = `https://meo.comick.pictures/${comic.md_covers[0].b2key}`;
            img.className = 'w-12 h-16 object-cover rounded';
            img.alt = comic.title;
            div.appendChild(img);
          }
          
          const info = document.createElement('div');
          info.innerHTML = `
            <div class="font-medium">${comic.title}</div>
            <div class="text-sm text-primary/60">${comic.slug}</div>
          `;
          div.appendChild(info);
          
          searchResults!.appendChild(div);
        });
      } catch (error) {
        console.error('Failed to search comics:', error);
        searchResults!.innerHTML = `
          <div class="p-3 bg-primary rounded-lg border border-red-500/30 text-red-500">
            Failed to search comics. Please try again.
          </div>
        `;
      }
    }, 300);
  });

  async function updateRSSLink() {
    const slugString = [...slugs].join(',');
    const lang = langSelect?.value || 'en';
    
    if (slugString) {
      try {
        const response = await fetch('/api/create-feed', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            slugs: [...slugs],
            lang
          })
        });
        
        if (!response.ok) throw new Error('Failed to create feed');
        
        const { feedId } = await response.json();
        generateRSSLink!.href = `/rss/${feedId}.xml`;
        generateRSSLink!.onclick = null;
      } catch (error) {
        console.error('Failed to generate feed:', error);
      }
    } else {
      generateRSSLink!.href = '#';
      generateRSSLink!.onclick = (e) => {
        e.preventDefault();
        return false;
      };
    }
  }

  // Initial render
  renderSlugs();
  updateRSSLink();

  // Update RSS link when language changes
  langSelect?.addEventListener('change', () => updateRSSLink());

  // Close search results when clicking outside
  document.addEventListener('click', (e) => {
    if (!searchResults?.contains(e.target as Node) && !searchInput?.contains(e.target as Node)) {
      searchResults?.classList.add('hidden');
    }
  });
</script> 